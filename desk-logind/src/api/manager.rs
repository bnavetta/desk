#![allow(clippy::all)]
// This code was autogenerated with `dbus-codegen-rust -s -d org.freedesktop.login1 -p /org/freedesktop/login1 -f org.freedesktop.login1.Manager -c blocking -m None -o desk-logind/src/api/manager`, see https://github.com/diwic/dbus-rs
use dbus;
use dbus::arg;
use dbus::blocking;

pub trait OrgFreedesktopLogin1Manager {
    fn get_session(&self, arg0: &str) -> Result<dbus::Path<'static>, dbus::Error>;
    fn get_session_by_pid(&self, arg0: u32) -> Result<dbus::Path<'static>, dbus::Error>;
    fn get_user(&self, arg0: u32) -> Result<dbus::Path<'static>, dbus::Error>;
    fn get_user_by_pid(&self, arg0: u32) -> Result<dbus::Path<'static>, dbus::Error>;
    fn get_seat(&self, arg0: &str) -> Result<dbus::Path<'static>, dbus::Error>;
    fn list_sessions(
        &self,
    ) -> Result<Vec<(String, u32, String, String, dbus::Path<'static>)>, dbus::Error>;
    fn list_users(&self) -> Result<Vec<(u32, String, dbus::Path<'static>)>, dbus::Error>;
    fn list_seats(&self) -> Result<Vec<(String, dbus::Path<'static>)>, dbus::Error>;
    fn list_inhibitors(
        &self,
    ) -> Result<Vec<(String, String, String, String, u32, u32)>, dbus::Error>;
    // Too many arguments
    // fn create_session(&self, arg0: u32, arg1: u32, arg2: &str, arg3: &str, arg4: &str, arg5: &str, arg6: &str, arg7: u32, arg8: &str, arg9: &str, arg10: bool, arg11: &str, arg12: &str, arg13: Vec<(&str, arg::Variant<Box<dyn arg::RefArg>>)>) -> Result<(String, dbus::Path<'static>, String, arg::OwnedFd, u32, String, u32, bool), dbus::Error>;
    fn release_session(&self, arg0: &str) -> Result<(), dbus::Error>;
    fn activate_session(&self, arg0: &str) -> Result<(), dbus::Error>;
    fn activate_session_on_seat(&self, arg0: &str, arg1: &str) -> Result<(), dbus::Error>;
    fn lock_session(&self, arg0: &str) -> Result<(), dbus::Error>;
    fn unlock_session(&self, arg0: &str) -> Result<(), dbus::Error>;
    fn lock_sessions(&self) -> Result<(), dbus::Error>;
    fn unlock_sessions(&self) -> Result<(), dbus::Error>;
    fn kill_session(&self, arg0: &str, arg1: &str, arg2: i32) -> Result<(), dbus::Error>;
    fn kill_user(&self, arg0: u32, arg1: i32) -> Result<(), dbus::Error>;
    fn terminate_session(&self, arg0: &str) -> Result<(), dbus::Error>;
    fn terminate_user(&self, arg0: u32) -> Result<(), dbus::Error>;
    fn terminate_seat(&self, arg0: &str) -> Result<(), dbus::Error>;
    fn set_user_linger(&self, arg0: u32, arg1: bool, arg2: bool) -> Result<(), dbus::Error>;
    fn attach_device(&self, arg0: &str, arg1: &str, arg2: bool) -> Result<(), dbus::Error>;
    fn flush_devices(&self, arg0: bool) -> Result<(), dbus::Error>;
    fn power_off(&self, arg0: bool) -> Result<(), dbus::Error>;
    fn reboot(&self, arg0: bool) -> Result<(), dbus::Error>;
    fn halt(&self, arg0: bool) -> Result<(), dbus::Error>;
    fn suspend(&self, arg0: bool) -> Result<(), dbus::Error>;
    fn hibernate(&self, arg0: bool) -> Result<(), dbus::Error>;
    fn hybrid_sleep(&self, arg0: bool) -> Result<(), dbus::Error>;
    fn suspend_then_hibernate(&self, arg0: bool) -> Result<(), dbus::Error>;
    fn can_power_off(&self) -> Result<String, dbus::Error>;
    fn can_reboot(&self) -> Result<String, dbus::Error>;
    fn can_halt(&self) -> Result<String, dbus::Error>;
    fn can_suspend(&self) -> Result<String, dbus::Error>;
    fn can_hibernate(&self) -> Result<String, dbus::Error>;
    fn can_hybrid_sleep(&self) -> Result<String, dbus::Error>;
    fn can_suspend_then_hibernate(&self) -> Result<String, dbus::Error>;
    fn schedule_shutdown(&self, arg0: &str, arg1: u64) -> Result<(), dbus::Error>;
    fn cancel_scheduled_shutdown(&self) -> Result<bool, dbus::Error>;
    fn inhibit(
        &self,
        arg0: &str,
        arg1: &str,
        arg2: &str,
        arg3: &str,
    ) -> Result<arg::OwnedFd, dbus::Error>;
    fn can_reboot_parameter(&self) -> Result<String, dbus::Error>;
    fn set_reboot_parameter_(&self, arg0: &str) -> Result<(), dbus::Error>;
    fn can_reboot_to_firmware_setup(&self) -> Result<String, dbus::Error>;
    fn set_reboot_to_firmware_setup_(&self, arg0: bool) -> Result<(), dbus::Error>;
    fn can_reboot_to_boot_loader_menu(&self) -> Result<String, dbus::Error>;
    fn set_reboot_to_boot_loader_menu_(&self, arg0: u64) -> Result<(), dbus::Error>;
    fn can_reboot_to_boot_loader_entry(&self) -> Result<String, dbus::Error>;
    fn set_reboot_to_boot_loader_entry_(&self, arg0: &str) -> Result<(), dbus::Error>;
    fn set_wall_message_(&self, arg0: &str, arg1: bool) -> Result<(), dbus::Error>;
    fn enable_wall_messages(&self) -> Result<bool, dbus::Error>;
    fn set_enable_wall_messages(&self, value: bool) -> Result<(), dbus::Error>;
    fn wall_message(&self) -> Result<String, dbus::Error>;
    fn set_wall_message(&self, value: String) -> Result<(), dbus::Error>;
    fn nauto_vts(&self) -> Result<u32, dbus::Error>;
    fn kill_only_users(&self) -> Result<Vec<String>, dbus::Error>;
    fn kill_exclude_users(&self) -> Result<Vec<String>, dbus::Error>;
    fn kill_user_processes(&self) -> Result<bool, dbus::Error>;
    fn reboot_parameter(&self) -> Result<String, dbus::Error>;
    fn reboot_to_firmware_setup(&self) -> Result<bool, dbus::Error>;
    fn reboot_to_boot_loader_menu(&self) -> Result<u64, dbus::Error>;
    fn reboot_to_boot_loader_entry(&self) -> Result<String, dbus::Error>;
    fn boot_loader_entries(&self) -> Result<Vec<String>, dbus::Error>;
    fn idle_hint(&self) -> Result<bool, dbus::Error>;
    fn idle_since_hint(&self) -> Result<u64, dbus::Error>;
    fn idle_since_hint_monotonic(&self) -> Result<u64, dbus::Error>;
    fn block_inhibited(&self) -> Result<String, dbus::Error>;
    fn delay_inhibited(&self) -> Result<String, dbus::Error>;
    fn inhibit_delay_max_usec(&self) -> Result<u64, dbus::Error>;
    fn user_stop_delay_usec(&self) -> Result<u64, dbus::Error>;
    fn handle_power_key(&self) -> Result<String, dbus::Error>;
    fn handle_suspend_key(&self) -> Result<String, dbus::Error>;
    fn handle_hibernate_key(&self) -> Result<String, dbus::Error>;
    fn handle_lid_switch(&self) -> Result<String, dbus::Error>;
    fn handle_lid_switch_external_power(&self) -> Result<String, dbus::Error>;
    fn handle_lid_switch_docked(&self) -> Result<String, dbus::Error>;
    fn holdoff_timeout_usec(&self) -> Result<u64, dbus::Error>;
    fn idle_action(&self) -> Result<String, dbus::Error>;
    fn idle_action_usec(&self) -> Result<u64, dbus::Error>;
    fn preparing_for_shutdown(&self) -> Result<bool, dbus::Error>;
    fn preparing_for_sleep(&self) -> Result<bool, dbus::Error>;
    fn scheduled_shutdown(&self) -> Result<(String, u64), dbus::Error>;
    fn docked(&self) -> Result<bool, dbus::Error>;
    fn lid_closed(&self) -> Result<bool, dbus::Error>;
    fn on_external_power(&self) -> Result<bool, dbus::Error>;
    fn remove_ipc(&self) -> Result<bool, dbus::Error>;
    fn runtime_directory_size(&self) -> Result<u64, dbus::Error>;
    fn inhibitors_max(&self) -> Result<u64, dbus::Error>;
    fn ncurrent_inhibitors(&self) -> Result<u64, dbus::Error>;
    fn sessions_max(&self) -> Result<u64, dbus::Error>;
    fn ncurrent_sessions(&self) -> Result<u64, dbus::Error>;
}

impl<'a, C: ::std::ops::Deref<Target = blocking::Connection>> OrgFreedesktopLogin1Manager
    for blocking::Proxy<'a, C>
{
    fn get_session(&self, arg0: &str) -> Result<dbus::Path<'static>, dbus::Error> {
        self.method_call("org.freedesktop.login1.Manager", "GetSession", (arg0,))
            .and_then(|r: (dbus::Path<'static>,)| Ok(r.0))
    }

    fn get_session_by_pid(&self, arg0: u32) -> Result<dbus::Path<'static>, dbus::Error> {
        self.method_call("org.freedesktop.login1.Manager", "GetSessionByPID", (arg0,))
            .and_then(|r: (dbus::Path<'static>,)| Ok(r.0))
    }

    fn get_user(&self, arg0: u32) -> Result<dbus::Path<'static>, dbus::Error> {
        self.method_call("org.freedesktop.login1.Manager", "GetUser", (arg0,))
            .and_then(|r: (dbus::Path<'static>,)| Ok(r.0))
    }

    fn get_user_by_pid(&self, arg0: u32) -> Result<dbus::Path<'static>, dbus::Error> {
        self.method_call("org.freedesktop.login1.Manager", "GetUserByPID", (arg0,))
            .and_then(|r: (dbus::Path<'static>,)| Ok(r.0))
    }

    fn get_seat(&self, arg0: &str) -> Result<dbus::Path<'static>, dbus::Error> {
        self.method_call("org.freedesktop.login1.Manager", "GetSeat", (arg0,))
            .and_then(|r: (dbus::Path<'static>,)| Ok(r.0))
    }

    fn list_sessions(
        &self,
    ) -> Result<Vec<(String, u32, String, String, dbus::Path<'static>)>, dbus::Error> {
        self.method_call("org.freedesktop.login1.Manager", "ListSessions", ())
            .and_then(|r: (Vec<(String, u32, String, String, dbus::Path<'static>)>,)| Ok(r.0))
    }

    fn list_users(&self) -> Result<Vec<(u32, String, dbus::Path<'static>)>, dbus::Error> {
        self.method_call("org.freedesktop.login1.Manager", "ListUsers", ())
            .and_then(|r: (Vec<(u32, String, dbus::Path<'static>)>,)| Ok(r.0))
    }

    fn list_seats(&self) -> Result<Vec<(String, dbus::Path<'static>)>, dbus::Error> {
        self.method_call("org.freedesktop.login1.Manager", "ListSeats", ())
            .and_then(|r: (Vec<(String, dbus::Path<'static>)>,)| Ok(r.0))
    }

    fn list_inhibitors(
        &self,
    ) -> Result<Vec<(String, String, String, String, u32, u32)>, dbus::Error> {
        self.method_call("org.freedesktop.login1.Manager", "ListInhibitors", ())
            .and_then(|r: (Vec<(String, String, String, String, u32, u32)>,)| Ok(r.0))
    }

    // Too many arguments
    // fn create_session(&self, arg0: u32, arg1: u32, arg2: &str, arg3: &str, arg4: &str, arg5: &str, arg6: &str, arg7: u32, arg8: &str, arg9: &str, arg10: bool, arg11: &str, arg12: &str, arg13: Vec<(&str, arg::Variant<Box<dyn arg::RefArg>>)>) -> Result<(String, dbus::Path<'static>, String, arg::OwnedFd, u32, String, u32, bool), dbus::Error> {
    //     self.method_call("org.freedesktop.login1.Manager", "CreateSession", (arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, ))
    // }

    fn release_session(&self, arg0: &str) -> Result<(), dbus::Error> {
        self.method_call("org.freedesktop.login1.Manager", "ReleaseSession", (arg0,))
    }

    fn activate_session(&self, arg0: &str) -> Result<(), dbus::Error> {
        self.method_call("org.freedesktop.login1.Manager", "ActivateSession", (arg0,))
    }

    fn activate_session_on_seat(&self, arg0: &str, arg1: &str) -> Result<(), dbus::Error> {
        self.method_call(
            "org.freedesktop.login1.Manager",
            "ActivateSessionOnSeat",
            (arg0, arg1),
        )
    }

    fn lock_session(&self, arg0: &str) -> Result<(), dbus::Error> {
        self.method_call("org.freedesktop.login1.Manager", "LockSession", (arg0,))
    }

    fn unlock_session(&self, arg0: &str) -> Result<(), dbus::Error> {
        self.method_call("org.freedesktop.login1.Manager", "UnlockSession", (arg0,))
    }

    fn lock_sessions(&self) -> Result<(), dbus::Error> {
        self.method_call("org.freedesktop.login1.Manager", "LockSessions", ())
    }

    fn unlock_sessions(&self) -> Result<(), dbus::Error> {
        self.method_call("org.freedesktop.login1.Manager", "UnlockSessions", ())
    }

    fn kill_session(&self, arg0: &str, arg1: &str, arg2: i32) -> Result<(), dbus::Error> {
        self.method_call(
            "org.freedesktop.login1.Manager",
            "KillSession",
            (arg0, arg1, arg2),
        )
    }

    fn kill_user(&self, arg0: u32, arg1: i32) -> Result<(), dbus::Error> {
        self.method_call("org.freedesktop.login1.Manager", "KillUser", (arg0, arg1))
    }

    fn terminate_session(&self, arg0: &str) -> Result<(), dbus::Error> {
        self.method_call(
            "org.freedesktop.login1.Manager",
            "TerminateSession",
            (arg0,),
        )
    }

    fn terminate_user(&self, arg0: u32) -> Result<(), dbus::Error> {
        self.method_call("org.freedesktop.login1.Manager", "TerminateUser", (arg0,))
    }

    fn terminate_seat(&self, arg0: &str) -> Result<(), dbus::Error> {
        self.method_call("org.freedesktop.login1.Manager", "TerminateSeat", (arg0,))
    }

    fn set_user_linger(&self, arg0: u32, arg1: bool, arg2: bool) -> Result<(), dbus::Error> {
        self.method_call(
            "org.freedesktop.login1.Manager",
            "SetUserLinger",
            (arg0, arg1, arg2),
        )
    }

    fn attach_device(&self, arg0: &str, arg1: &str, arg2: bool) -> Result<(), dbus::Error> {
        self.method_call(
            "org.freedesktop.login1.Manager",
            "AttachDevice",
            (arg0, arg1, arg2),
        )
    }

    fn flush_devices(&self, arg0: bool) -> Result<(), dbus::Error> {
        self.method_call("org.freedesktop.login1.Manager", "FlushDevices", (arg0,))
    }

    fn power_off(&self, arg0: bool) -> Result<(), dbus::Error> {
        self.method_call("org.freedesktop.login1.Manager", "PowerOff", (arg0,))
    }

    fn reboot(&self, arg0: bool) -> Result<(), dbus::Error> {
        self.method_call("org.freedesktop.login1.Manager", "Reboot", (arg0,))
    }

    fn halt(&self, arg0: bool) -> Result<(), dbus::Error> {
        self.method_call("org.freedesktop.login1.Manager", "Halt", (arg0,))
    }

    fn suspend(&self, arg0: bool) -> Result<(), dbus::Error> {
        self.method_call("org.freedesktop.login1.Manager", "Suspend", (arg0,))
    }

    fn hibernate(&self, arg0: bool) -> Result<(), dbus::Error> {
        self.method_call("org.freedesktop.login1.Manager", "Hibernate", (arg0,))
    }

    fn hybrid_sleep(&self, arg0: bool) -> Result<(), dbus::Error> {
        self.method_call("org.freedesktop.login1.Manager", "HybridSleep", (arg0,))
    }

    fn suspend_then_hibernate(&self, arg0: bool) -> Result<(), dbus::Error> {
        self.method_call(
            "org.freedesktop.login1.Manager",
            "SuspendThenHibernate",
            (arg0,),
        )
    }

    fn can_power_off(&self) -> Result<String, dbus::Error> {
        self.method_call("org.freedesktop.login1.Manager", "CanPowerOff", ())
            .and_then(|r: (String,)| Ok(r.0))
    }

    fn can_reboot(&self) -> Result<String, dbus::Error> {
        self.method_call("org.freedesktop.login1.Manager", "CanReboot", ())
            .and_then(|r: (String,)| Ok(r.0))
    }

    fn can_halt(&self) -> Result<String, dbus::Error> {
        self.method_call("org.freedesktop.login1.Manager", "CanHalt", ())
            .and_then(|r: (String,)| Ok(r.0))
    }

    fn can_suspend(&self) -> Result<String, dbus::Error> {
        self.method_call("org.freedesktop.login1.Manager", "CanSuspend", ())
            .and_then(|r: (String,)| Ok(r.0))
    }

    fn can_hibernate(&self) -> Result<String, dbus::Error> {
        self.method_call("org.freedesktop.login1.Manager", "CanHibernate", ())
            .and_then(|r: (String,)| Ok(r.0))
    }

    fn can_hybrid_sleep(&self) -> Result<String, dbus::Error> {
        self.method_call("org.freedesktop.login1.Manager", "CanHybridSleep", ())
            .and_then(|r: (String,)| Ok(r.0))
    }

    fn can_suspend_then_hibernate(&self) -> Result<String, dbus::Error> {
        self.method_call(
            "org.freedesktop.login1.Manager",
            "CanSuspendThenHibernate",
            (),
        )
        .and_then(|r: (String,)| Ok(r.0))
    }

    fn schedule_shutdown(&self, arg0: &str, arg1: u64) -> Result<(), dbus::Error> {
        self.method_call(
            "org.freedesktop.login1.Manager",
            "ScheduleShutdown",
            (arg0, arg1),
        )
    }

    fn cancel_scheduled_shutdown(&self) -> Result<bool, dbus::Error> {
        self.method_call(
            "org.freedesktop.login1.Manager",
            "CancelScheduledShutdown",
            (),
        )
        .and_then(|r: (bool,)| Ok(r.0))
    }

    fn inhibit(
        &self,
        arg0: &str,
        arg1: &str,
        arg2: &str,
        arg3: &str,
    ) -> Result<arg::OwnedFd, dbus::Error> {
        self.method_call(
            "org.freedesktop.login1.Manager",
            "Inhibit",
            (arg0, arg1, arg2, arg3),
        )
        .and_then(|r: (arg::OwnedFd,)| Ok(r.0))
    }

    fn can_reboot_parameter(&self) -> Result<String, dbus::Error> {
        self.method_call("org.freedesktop.login1.Manager", "CanRebootParameter", ())
            .and_then(|r: (String,)| Ok(r.0))
    }

    fn set_reboot_parameter_(&self, arg0: &str) -> Result<(), dbus::Error> {
        self.method_call(
            "org.freedesktop.login1.Manager",
            "SetRebootParameter",
            (arg0,),
        )
    }

    fn can_reboot_to_firmware_setup(&self) -> Result<String, dbus::Error> {
        self.method_call(
            "org.freedesktop.login1.Manager",
            "CanRebootToFirmwareSetup",
            (),
        )
        .and_then(|r: (String,)| Ok(r.0))
    }

    fn set_reboot_to_firmware_setup_(&self, arg0: bool) -> Result<(), dbus::Error> {
        self.method_call(
            "org.freedesktop.login1.Manager",
            "SetRebootToFirmwareSetup",
            (arg0,),
        )
    }

    fn can_reboot_to_boot_loader_menu(&self) -> Result<String, dbus::Error> {
        self.method_call(
            "org.freedesktop.login1.Manager",
            "CanRebootToBootLoaderMenu",
            (),
        )
        .and_then(|r: (String,)| Ok(r.0))
    }

    fn set_reboot_to_boot_loader_menu_(&self, arg0: u64) -> Result<(), dbus::Error> {
        self.method_call(
            "org.freedesktop.login1.Manager",
            "SetRebootToBootLoaderMenu",
            (arg0,),
        )
    }

    fn can_reboot_to_boot_loader_entry(&self) -> Result<String, dbus::Error> {
        self.method_call(
            "org.freedesktop.login1.Manager",
            "CanRebootToBootLoaderEntry",
            (),
        )
        .and_then(|r: (String,)| Ok(r.0))
    }

    fn set_reboot_to_boot_loader_entry_(&self, arg0: &str) -> Result<(), dbus::Error> {
        self.method_call(
            "org.freedesktop.login1.Manager",
            "SetRebootToBootLoaderEntry",
            (arg0,),
        )
    }

    fn set_wall_message_(&self, arg0: &str, arg1: bool) -> Result<(), dbus::Error> {
        self.method_call(
            "org.freedesktop.login1.Manager",
            "SetWallMessage",
            (arg0, arg1),
        )
    }

    fn enable_wall_messages(&self) -> Result<bool, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.login1.Manager",
            "EnableWallMessages",
        )
    }

    fn wall_message(&self) -> Result<String, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.login1.Manager",
            "WallMessage",
        )
    }

    fn nauto_vts(&self) -> Result<u32, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.login1.Manager",
            "NAutoVTs",
        )
    }

    fn kill_only_users(&self) -> Result<Vec<String>, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.login1.Manager",
            "KillOnlyUsers",
        )
    }

    fn kill_exclude_users(&self) -> Result<Vec<String>, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.login1.Manager",
            "KillExcludeUsers",
        )
    }

    fn kill_user_processes(&self) -> Result<bool, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.login1.Manager",
            "KillUserProcesses",
        )
    }

    fn reboot_parameter(&self) -> Result<String, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.login1.Manager",
            "RebootParameter",
        )
    }

    fn reboot_to_firmware_setup(&self) -> Result<bool, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.login1.Manager",
            "RebootToFirmwareSetup",
        )
    }

    fn reboot_to_boot_loader_menu(&self) -> Result<u64, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.login1.Manager",
            "RebootToBootLoaderMenu",
        )
    }

    fn reboot_to_boot_loader_entry(&self) -> Result<String, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.login1.Manager",
            "RebootToBootLoaderEntry",
        )
    }

    fn boot_loader_entries(&self) -> Result<Vec<String>, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.login1.Manager",
            "BootLoaderEntries",
        )
    }

    fn idle_hint(&self) -> Result<bool, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.login1.Manager",
            "IdleHint",
        )
    }

    fn idle_since_hint(&self) -> Result<u64, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.login1.Manager",
            "IdleSinceHint",
        )
    }

    fn idle_since_hint_monotonic(&self) -> Result<u64, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.login1.Manager",
            "IdleSinceHintMonotonic",
        )
    }

    fn block_inhibited(&self) -> Result<String, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.login1.Manager",
            "BlockInhibited",
        )
    }

    fn delay_inhibited(&self) -> Result<String, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.login1.Manager",
            "DelayInhibited",
        )
    }

    fn inhibit_delay_max_usec(&self) -> Result<u64, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.login1.Manager",
            "InhibitDelayMaxUSec",
        )
    }

    fn user_stop_delay_usec(&self) -> Result<u64, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.login1.Manager",
            "UserStopDelayUSec",
        )
    }

    fn handle_power_key(&self) -> Result<String, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.login1.Manager",
            "HandlePowerKey",
        )
    }

    fn handle_suspend_key(&self) -> Result<String, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.login1.Manager",
            "HandleSuspendKey",
        )
    }

    fn handle_hibernate_key(&self) -> Result<String, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.login1.Manager",
            "HandleHibernateKey",
        )
    }

    fn handle_lid_switch(&self) -> Result<String, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.login1.Manager",
            "HandleLidSwitch",
        )
    }

    fn handle_lid_switch_external_power(&self) -> Result<String, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.login1.Manager",
            "HandleLidSwitchExternalPower",
        )
    }

    fn handle_lid_switch_docked(&self) -> Result<String, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.login1.Manager",
            "HandleLidSwitchDocked",
        )
    }

    fn holdoff_timeout_usec(&self) -> Result<u64, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.login1.Manager",
            "HoldoffTimeoutUSec",
        )
    }

    fn idle_action(&self) -> Result<String, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.login1.Manager",
            "IdleAction",
        )
    }

    fn idle_action_usec(&self) -> Result<u64, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.login1.Manager",
            "IdleActionUSec",
        )
    }

    fn preparing_for_shutdown(&self) -> Result<bool, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.login1.Manager",
            "PreparingForShutdown",
        )
    }

    fn preparing_for_sleep(&self) -> Result<bool, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.login1.Manager",
            "PreparingForSleep",
        )
    }

    fn scheduled_shutdown(&self) -> Result<(String, u64), dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.login1.Manager",
            "ScheduledShutdown",
        )
    }

    fn docked(&self) -> Result<bool, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.login1.Manager",
            "Docked",
        )
    }

    fn lid_closed(&self) -> Result<bool, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.login1.Manager",
            "LidClosed",
        )
    }

    fn on_external_power(&self) -> Result<bool, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.login1.Manager",
            "OnExternalPower",
        )
    }

    fn remove_ipc(&self) -> Result<bool, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.login1.Manager",
            "RemoveIPC",
        )
    }

    fn runtime_directory_size(&self) -> Result<u64, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.login1.Manager",
            "RuntimeDirectorySize",
        )
    }

    fn inhibitors_max(&self) -> Result<u64, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.login1.Manager",
            "InhibitorsMax",
        )
    }

    fn ncurrent_inhibitors(&self) -> Result<u64, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.login1.Manager",
            "NCurrentInhibitors",
        )
    }

    fn sessions_max(&self) -> Result<u64, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.login1.Manager",
            "SessionsMax",
        )
    }

    fn ncurrent_sessions(&self) -> Result<u64, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.login1.Manager",
            "NCurrentSessions",
        )
    }

    fn set_enable_wall_messages(&self, value: bool) -> Result<(), dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::set(
            &self,
            "org.freedesktop.login1.Manager",
            "EnableWallMessages",
            value,
        )
    }

    fn set_wall_message(&self, value: String) -> Result<(), dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::set(
            &self,
            "org.freedesktop.login1.Manager",
            "WallMessage",
            value,
        )
    }
}

#[derive(Debug)]
pub struct OrgFreedesktopLogin1ManagerSessionNew {
    pub arg0: String,
    pub arg1: dbus::Path<'static>,
}

impl arg::AppendAll for OrgFreedesktopLogin1ManagerSessionNew {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.arg0, i);
        arg::RefArg::append(&self.arg1, i);
    }
}

impl arg::ReadAll for OrgFreedesktopLogin1ManagerSessionNew {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(OrgFreedesktopLogin1ManagerSessionNew {
            arg0: i.read()?,
            arg1: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for OrgFreedesktopLogin1ManagerSessionNew {
    const NAME: &'static str = "SessionNew";
    const INTERFACE: &'static str = "org.freedesktop.login1.Manager";
}

#[derive(Debug)]
pub struct OrgFreedesktopLogin1ManagerSessionRemoved {
    pub arg0: String,
    pub arg1: dbus::Path<'static>,
}

impl arg::AppendAll for OrgFreedesktopLogin1ManagerSessionRemoved {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.arg0, i);
        arg::RefArg::append(&self.arg1, i);
    }
}

impl arg::ReadAll for OrgFreedesktopLogin1ManagerSessionRemoved {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(OrgFreedesktopLogin1ManagerSessionRemoved {
            arg0: i.read()?,
            arg1: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for OrgFreedesktopLogin1ManagerSessionRemoved {
    const NAME: &'static str = "SessionRemoved";
    const INTERFACE: &'static str = "org.freedesktop.login1.Manager";
}

#[derive(Debug)]
pub struct OrgFreedesktopLogin1ManagerUserNew {
    pub arg0: u32,
    pub arg1: dbus::Path<'static>,
}

impl arg::AppendAll for OrgFreedesktopLogin1ManagerUserNew {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.arg0, i);
        arg::RefArg::append(&self.arg1, i);
    }
}

impl arg::ReadAll for OrgFreedesktopLogin1ManagerUserNew {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(OrgFreedesktopLogin1ManagerUserNew {
            arg0: i.read()?,
            arg1: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for OrgFreedesktopLogin1ManagerUserNew {
    const NAME: &'static str = "UserNew";
    const INTERFACE: &'static str = "org.freedesktop.login1.Manager";
}

#[derive(Debug)]
pub struct OrgFreedesktopLogin1ManagerUserRemoved {
    pub arg0: u32,
    pub arg1: dbus::Path<'static>,
}

impl arg::AppendAll for OrgFreedesktopLogin1ManagerUserRemoved {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.arg0, i);
        arg::RefArg::append(&self.arg1, i);
    }
}

impl arg::ReadAll for OrgFreedesktopLogin1ManagerUserRemoved {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(OrgFreedesktopLogin1ManagerUserRemoved {
            arg0: i.read()?,
            arg1: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for OrgFreedesktopLogin1ManagerUserRemoved {
    const NAME: &'static str = "UserRemoved";
    const INTERFACE: &'static str = "org.freedesktop.login1.Manager";
}

#[derive(Debug)]
pub struct OrgFreedesktopLogin1ManagerSeatNew {
    pub arg0: String,
    pub arg1: dbus::Path<'static>,
}

impl arg::AppendAll for OrgFreedesktopLogin1ManagerSeatNew {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.arg0, i);
        arg::RefArg::append(&self.arg1, i);
    }
}

impl arg::ReadAll for OrgFreedesktopLogin1ManagerSeatNew {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(OrgFreedesktopLogin1ManagerSeatNew {
            arg0: i.read()?,
            arg1: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for OrgFreedesktopLogin1ManagerSeatNew {
    const NAME: &'static str = "SeatNew";
    const INTERFACE: &'static str = "org.freedesktop.login1.Manager";
}

#[derive(Debug)]
pub struct OrgFreedesktopLogin1ManagerSeatRemoved {
    pub arg0: String,
    pub arg1: dbus::Path<'static>,
}

impl arg::AppendAll for OrgFreedesktopLogin1ManagerSeatRemoved {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.arg0, i);
        arg::RefArg::append(&self.arg1, i);
    }
}

impl arg::ReadAll for OrgFreedesktopLogin1ManagerSeatRemoved {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(OrgFreedesktopLogin1ManagerSeatRemoved {
            arg0: i.read()?,
            arg1: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for OrgFreedesktopLogin1ManagerSeatRemoved {
    const NAME: &'static str = "SeatRemoved";
    const INTERFACE: &'static str = "org.freedesktop.login1.Manager";
}

#[derive(Debug)]
pub struct OrgFreedesktopLogin1ManagerPrepareForShutdown {
    pub arg0: bool,
}

impl arg::AppendAll for OrgFreedesktopLogin1ManagerPrepareForShutdown {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.arg0, i);
    }
}

impl arg::ReadAll for OrgFreedesktopLogin1ManagerPrepareForShutdown {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(OrgFreedesktopLogin1ManagerPrepareForShutdown { arg0: i.read()? })
    }
}

impl dbus::message::SignalArgs for OrgFreedesktopLogin1ManagerPrepareForShutdown {
    const NAME: &'static str = "PrepareForShutdown";
    const INTERFACE: &'static str = "org.freedesktop.login1.Manager";
}

#[derive(Debug)]
pub struct OrgFreedesktopLogin1ManagerPrepareForSleep {
    pub arg0: bool,
}

impl arg::AppendAll for OrgFreedesktopLogin1ManagerPrepareForSleep {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.arg0, i);
    }
}

impl arg::ReadAll for OrgFreedesktopLogin1ManagerPrepareForSleep {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(OrgFreedesktopLogin1ManagerPrepareForSleep { arg0: i.read()? })
    }
}

impl dbus::message::SignalArgs for OrgFreedesktopLogin1ManagerPrepareForSleep {
    const NAME: &'static str = "PrepareForSleep";
    const INTERFACE: &'static str = "org.freedesktop.login1.Manager";
}
